"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScratchCloud = void 0;
const events_1 = __importDefault(require("events"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const ws_1 = require("ws");
const sFetch = ({ headers = {}, body = "", sessionId = "", path = "/", method = "GET", hostname = "scratch.mit.edu" }) => {
    const headerObj = Object.assign({
        Cookie: "scratchcsrftoken=a; scratchlanguage=en;",
        "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36",
        "x-csrftoken": "a",
        "x-requested-with": "XMLHttpRequest",
        referer: "https://scratch.mit.edu",
        "Content-Length": Buffer.byteLength(body)
    }, headers);
    if (sessionId)
        headerObj.Cookie = `${headerObj.Cookie} scratchsessionsid=${sessionId}`;
    return (0, node_fetch_1.default)(`https://${hostname}${path}`, {
        method,
        headers: headerObj,
        body: method === "POST" ? body : undefined
    });
};
const validateLogin = () => __awaiter(void 0, void 0, void 0, function* () {
    return yield (yield sFetch({})).ok;
});
class ScratchCloud {
    constructor() {
        this.loginData = {
            username: "",
            password: ""
        };
        this.sessionId = "";
        this.token = "";
        this.valid = false;
    }
    login(username, password) {
        return __awaiter(this, void 0, void 0, function* () {
            this.loginData = {
                username,
                password
            };
            const req = yield sFetch({
                path: "/login/",
                method: "POST",
                body: JSON.stringify(this.loginData),
                headers: {}
            }).catch(() => {
                throw new TypeError("Invalid username or password.");
            });
            const res = yield req.json().catch(() => {
                throw new Error("Scratch server gave an invalid response.");
            });
            if (res.msg) {
                throw new Error(res.msg);
            }
            this.token = res.token;
            this.sessionId = req.headers
                .raw()["set-cookie"][0].match(/scratchsessionsid="(.*)";/)[1];
            this.valid = yield validateLogin();
        });
    }
    createSession(project, turbowarp = false) {
        return new ScratchCloud.Session(Object.assign(Object.assign({}, this.loginData), { sessionId: this.sessionId }), project, turbowarp);
    }
}
exports.ScratchCloud = ScratchCloud;
(function (ScratchCloud) {
    ScratchCloud.cloudPrefix = "☁ ";
    class Session extends events_1.default {
        constructor(userData, projectId, turbowarp = false) {
            super();
            this.userData = userData;
            this.projectId = projectId;
            this.turbowarp = turbowarp;
            this.connectionAttempts = 0;
            this.queuedPackets = [];
            this.connection = null;
            this.variables = {};
            this.autoPrefix = true;
            this.maxCharacters = turbowarp ? 100000 : 256;
            this.open();
        }
        open() {
            this.connection = new ws_1.WebSocket(`wss://${this.turbowarp
                ? "clouddata.turbowarp.org"
                : "clouddata.scratch.mit.edu"}/`, {
                headers: {
                    cookie: this.turbowarp
                        ? ""
                        : `scratchsessionsid=${this.userData.sessionId};`,
                    origin: this.turbowarp ? "turbowarp.org" : "https://scratch.mit.edu"
                }
            });
            this.connection.on("open", this.onOpen.bind(this));
            this.connection.on("message", this.onMessage.bind(this));
            this.connection.on("close", this.onClose.bind(this));
            this.connection.on("error", this.onError.bind(this));
        }
        exponentialTimeout() {
            return (Math.pow(2, Math.min(this.connectionAttempts, 5)) - 1) * 1000;
        }
        randomizeDuration(t) {
            return Math.random() * t;
        }
        createPacket(methodName, dataName, dataValue) {
            return {
                method: methodName,
                user: this.userData.username,
                project_id: this.projectId,
                name: dataName,
                value: dataValue
            };
        }
        sendPacket(packet) {
            if (this.connection && this.connection.readyState === ws_1.WebSocket.OPEN) {
                this.connection.send(`${JSON.stringify(packet)}\n`);
            }
            else {
                this.queuedPackets.push(packet);
            }
        }
        handlePacket(packet) {
            function validatePacket(p) {
                return typeof p === "object" && p.method === "set";
            }
            if (!validatePacket(packet))
                return;
            const isInitialSet = !(packet.name in this.variables);
            this.variables[packet.name] = packet.value;
            if (!isInitialSet)
                this.emit("set", packet.name, packet.value);
            else
                this.emit("addvariable", packet.name, packet.value);
        }
        onOpen() {
            this.connectionAttempts = 1;
            this.sendPacket(this.createPacket("handshake"));
            this.queuedPackets.forEach(this.sendPacket.bind(this));
            this.queuedPackets = [];
            this.emit("open");
        }
        onMessage(message) {
            const data = message.toString();
            const isInitialSetup = data.length > 2 && Object.keys(this.variables).length === 0;
            data.split("\n").forEach((p) => {
                if (p) {
                    this.handlePacket(JSON.parse(p));
                }
            });
            if (isInitialSetup) {
                this.emit("setup");
            }
        }
        onClose() {
            this.emit("close");
            const timeout = this.randomizeDuration(this.exponentialTimeout());
            setTimeout(this.open.bind(this), timeout);
        }
        onError(err) {
            this.emit("error", err);
        }
        set(name, value) {
            value = String(value);
            if (this.autoPrefix && !name.startsWith(ScratchCloud.cloudPrefix)) {
                name = `${ScratchCloud.cloudPrefix}${name}`;
            }
            if (isNaN(Number(value))) {
                console.warn("Invalid cloud variable value. Can only contain numbers.");
            }
            else if (value.length > this.maxCharacters) {
                console.warn(`Variable length is too long. Maximum of ${this.maxCharacters} digits.`);
            }
            else {
                this.sendPacket(this.createPacket("set", name, value));
                this.variables[name] = value;
            }
        }
        get(name) {
            if (this.autoPrefix && !name.startsWith(ScratchCloud.cloudPrefix)) {
                name = `${ScratchCloud.cloudPrefix}${name}`;
            }
            return name in this.variables ? String(this.variables[name]) : undefined;
        }
        enableAutoPrefix() {
            this.autoPrefix = true;
        }
        disableAutoPrefix() {
            this.autoPrefix = false;
        }
        on(eventName, listener) {
            return super.on(eventName, listener);
        }
        once(eventName, listener) {
            return super.once(eventName, listener);
        }
    }
    ScratchCloud.Session = Session;
})(ScratchCloud = exports.ScratchCloud || (exports.ScratchCloud = {}));
//# sourceMappingURL=index.js.map